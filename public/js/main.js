// public/js/main.js (Increased SortableJS animation)
document.addEventListener('DOMContentLoaded', () => {
    // --- References ---
    const uploadTriggerButton = document.getElementById('upload-trigger-btn'); const uploadModal = document.getElementById('upload-modal'); const uploadOverlay = document.getElementById('upload-overlay'); const closeUploadModalButton = document.getElementById('close-upload-modal-btn'); const uploadCategorySelect = document.getElementById('upload-category-select');
    const editModal = document.getElementById('edit-modal'); const editOverlay = document.getElementById('edit-overlay'); const closeEditModalButton = document.getElementById('close-edit-modal-btn'); const editForm = document.getElementById('edit-form'); const editTitleInput = document.getElementById('edit-title'); const editDescriptionInput = document.getElementById('edit-description'); const editFilenameSpan = document.getElementById('edit-filename'); const editCategorySelect = document.getElementById('edit-category-select');
    const settingsTriggerButton = document.getElementById('settings-trigger-btn'); const settingsModal = document.getElementById('settings-modal'); const settingsOverlay = document.getElementById('settings-overlay'); const closeSettingsModalButton = document.getElementById('close-settings-modal-btn'); const categoryListUl = document.getElementById('category-list'); const newCategoryInput = document.getElementById('new-category-input'); const addCategoryButton = document.getElementById('add-category-btn'); const settingsCategoryStatus = document.getElementById('settings-category-status');
    const mainContent = document.getElementById('main-content'); const homeLink = document.getElementById('home-link');
    const defaultCategories = ["Video", "Movie", "TV Show", "Image", "Other"]; let categorySortableInstance = null;
    const themeSelect = document.getElementById('theme-select'); const saveThemeButton = document.getElementById('save-theme-btn'); const deleteSelectedThemeButton = document.getElementById('delete-selected-theme-btn'); const themeStatus = document.getElementById('theme-status');
    const uploadThemeForm = document.getElementById('upload-theme-form'); const themeFileInput = document.getElementById('theme-file-input'); const uploadThemeStatus = document.getElementById('upload-theme-status');
    const mediaPathInput = document.getElementById('media-folder-path'); const saveMediaPathButton = document.getElementById('save-media-path-btn'); const mediaPathStatus = document.getElementById('media-path-status');
    const themeConfirmBar = document.getElementById('theme-confirm-bar'); const themeConfirmMessage = document.getElementById('theme-confirm-message'); const themeConfirmBtn = document.getElementById('theme-confirm-btn'); const themeRevertBtn = document.getElementById('theme-revert-btn'); const themeTimerDisplay = document.getElementById('theme-timer-display');
    let revertThemeTimer = null; let revertTimeoutSeconds = 10;
    const customThemeNameInput = document.getElementById('custom-theme-name'); const customThemeCssTextarea = document.getElementById('custom-theme-css'); const saveCustomThemeButton = document.getElementById('save-custom-theme-btn'); const customThemeStatus = document.getElementById('custom-theme-status');
    const imageViewerModal = document.getElementById('image-viewer-modal'); const imageViewerOverlay = document.getElementById('image-viewer-overlay'); const imageViewerImg = document.getElementById('image-viewer-img'); const closeImageViewerButton = document.getElementById('close-image-viewer-btn');
    const addCategoryModal = document.getElementById('add-category-modal'); const addCategoryModalOverlay = document.getElementById('add-category-modal-overlay'); const closeAddCategoryModalButton = document.getElementById('close-add-category-modal-btn');
    const addCategoryModalForm = document.getElementById('add-category-modal-form'); const addCategoryModalInput = document.getElementById('new-category-name-modal'); const addCategoryModalImageInput = document.getElementById('new-category-image-modal'); const addCategoryModalSubmitButton = document.getElementById('add-category-submit-btn'); const addCategoryModalStatus = document.getElementById('add-category-modal-status');
    const imageViewerPrevBtn = document.getElementById('image-viewer-prev'); const imageViewerNextBtn = document.getElementById('image-viewer-next');
    let currentImageViewerItems = []; let currentImageViewerIndex = -1;

    // --- Theme Confirmation Logic ---
    function hideConfirmBar() { if (themeConfirmBar) themeConfirmBar.style.display = 'none'; if (revertThemeTimer) clearTimeout(revertThemeTimer); revertThemeTimer = null; if (themeConfirmBtn) themeConfirmBtn.onclick = null; if (themeRevertBtn) themeRevertBtn.onclick = null; }
    async function revertToDefaultTheme() { try { const response = await fetch('/api/settings/theme', { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ theme: 'default' }), }); if (!response.ok) { const errorData = await response.json(); throw new Error(errorData.error || 'Failed update theme'); } window.location.reload(); } catch (error) { console.error('Error reverting theme:', error); alert(`Failed to revert theme: ${error.message}`); hideConfirmBar(); } }
    function showConfirmBar(appliedThemeName) { if (!themeConfirmBar || !themeConfirmMessage || !themeConfirmBtn || !themeRevertBtn || !themeTimerDisplay) { console.error("Confirmation bar elements missing!"); return; } themeConfirmMessage.textContent = `Theme '${appliedThemeName}' applied. Okay?`; themeConfirmBar.style.display = 'flex'; if (revertThemeTimer) clearTimeout(revertThemeTimer); let secondsLeft = revertTimeoutSeconds; themeTimerDisplay.textContent = `(Reverting in ${secondsLeft}s)`; const intervalId = setInterval(() => { secondsLeft--; themeTimerDisplay.textContent = `(Reverting in ${secondsLeft}s)`; if (secondsLeft <= 0) clearInterval(intervalId); }, 1000); revertThemeTimer = setTimeout(() => { clearInterval(intervalId); revertToDefaultTheme(); }, secondsLeft * 1000); themeConfirmBtn.onclick = () => { clearTimeout(revertThemeTimer); clearInterval(intervalId); hideConfirmBar(); }; themeRevertBtn.onclick = () => { clearTimeout(revertThemeTimer); clearInterval(intervalId); hideConfirmBar(); revertToDefaultTheme(); }; }
    const themeApplied = sessionStorage.getItem('themeApplyAttempt'); if (themeApplied) { sessionStorage.removeItem('themeApplyAttempt'); setTimeout(() => showConfirmBar(themeApplied), 0); }

    // --- Template Function ---
    function createItemElement(item, index = -1) { const article = document.createElement('article'); article.className = 'video-item'; const playerContainer = document.createElement('div'); playerContainer.className = 'video-player-container'; if (item.category === 'Image') { const img = document.createElement('img'); const imgSrc = `/serve/${item.filename}`; img.src = imgSrc; img.alt = item.title; img.className = 'item-image-thumbnail'; img.dataset.fullsrc = imgSrc; img.dataset.index = index; playerContainer.appendChild(img); } else { const video = document.createElement('video'); video.controls = true; video.preload = 'metadata'; video.width = '100%'; const source = document.createElement('source'); source.src = `/serve/${item.filename}`; source.type = 'video/mp4'; video.appendChild(source); video.appendChild(document.createTextNode('Your browser does not support the video tag.')); playerContainer.appendChild(video); } const infoDiv = document.createElement('div'); infoDiv.className = 'video-info'; const titleH3 = document.createElement('h3'); titleH3.className = 'video-title'; titleH3.textContent = item.title; const categoryP = document.createElement('p'); categoryP.className = 'video-category'; categoryP.innerHTML = `<strong>Category:</strong> ${item.category || 'Uncategorized'}`; const descriptionP = document.createElement('p'); descriptionP.className = 'video-description'; descriptionP.textContent = item.description; const metaP = document.createElement('p'); metaP.className = 'video-meta'; const small = document.createElement('small'); small.textContent = `Uploaded: ${new Date(item.upload_date).toLocaleDateString()}`; metaP.appendChild(small); const actionsDiv = document.createElement('div'); actionsDiv.className = 'video-actions'; const editButton = document.createElement('button'); editButton.className = 'action-button edit-button edit-trigger-btn'; editButton.textContent = 'Edit'; editButton.dataset.videoId = item.id; editButton.dataset.videoTitle = item.title; editButton.dataset.videoDescription = item.description; editButton.dataset.videoFilename = item.filename; editButton.dataset.videoCategory = item.category || ''; actionsDiv.appendChild(editButton); const deleteForm = document.createElement('form'); deleteForm.action = `/delete/${item.id}`; deleteForm.method = 'POST'; deleteForm.style.display = 'inline'; const deleteButton = document.createElement('button'); deleteButton.type = 'submit'; deleteButton.className = 'action-button delete-button'; deleteButton.textContent = 'Delete'; deleteForm.appendChild(deleteButton); actionsDiv.appendChild(deleteForm); infoDiv.appendChild(titleH3); infoDiv.appendChild(categoryP); infoDiv.appendChild(descriptionP); infoDiv.appendChild(metaP); infoDiv.appendChild(actionsDiv); article.appendChild(playerContainer); article.appendChild(infoDiv); return article; }

    // --- SPA Rendering ---
    async function renderHomePage() { currentImageViewerItems = []; currentImageViewerIndex = -1; if (!mainContent) return; mainContent.innerHTML = '<div class="loading-indicator">Loading Categories...</div>'; if (categorySortableInstance) { categorySortableInstance.destroy(); categorySortableInstance = null; } try { const response = await fetch('/api/categories'); if (!response.ok) throw new Error('Failed fetch categories'); const data = await response.json(); const categories = data.categories || []; mainContent.innerHTML = ''; const categoryGrid = document.createElement('div'); categoryGrid.className = 'category-grid'; categoryGrid.id = 'category-grid-container'; if (categories.length > 0) { categories.forEach(category => { const squircle = document.createElement('a'); squircle.href = `/category/${encodeURIComponent(category.name)}`; squircle.className = 'category-squircle'; squircle.dataset.category = category.name; squircle.dataset.categoryId = category.name; if(category.image_filename) { const img = document.createElement('img'); img.src = `/images/categories/${category.image_filename}`; img.alt = category.name; img.style.maxHeight = '60%'; img.style.maxWidth = '80%'; img.onerror = function() { this.src = '/images/placeholder.png'; this.alt=`${category.name} (Img Err)`; this.onerror=null; const nameSpanFallback = document.createElement('span'); nameSpanFallback.textContent = category.name; this.replaceWith(nameSpanFallback); }; squircle.appendChild(img); const nameSpan = document.createElement('span'); nameSpan.textContent = category.name; nameSpan.style.marginTop = '10px'; squircle.appendChild(nameSpan); } else { squircle.textContent = category.name; } squircle.addEventListener('click', handleCategoryClick); categoryGrid.appendChild(squircle); }); } const addSquircle = document.createElement('div'); addSquircle.className = 'category-squircle category-squircle--add'; addSquircle.id = 'add-category-squircle'; addSquircle.innerHTML = '<span class="plus-icon">+</span><span>Add Category</span>'; addSquircle.addEventListener('click', openAddCategoryModal); categoryGrid.appendChild(addSquircle); mainContent.appendChild(categoryGrid);
            if (typeof Sortable !== 'undefined') {
                 categorySortableInstance = Sortable.create(categoryGrid, {
                    // *** Increased animation duration ***
                    animation: 450, // ms, animation speed (try 300ms)
                    ghostClass: 'sortable-ghost',
                    dragClass: 'sortable-drag',
                    filter: '.category-squircle--add', // Ignore the add squircle
                    onMove: function (evt) { // Prevent dropping after the add squircle
                        return evt.related.id !== 'add-category-squircle';
                    },
                    onEnd: async function (evt) {
                         const orderedCategories = [];
                         categoryGrid.querySelectorAll('.category-squircle:not(.category-squircle--add)').forEach(el => { orderedCategories.push(el.dataset.category); });
                         try { const response = await fetch('/api/categories/order', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ order: orderedCategories }), }); if (!response.ok) { const errorData = await response.json(); throw new Error(errorData.error || 'Failed save order'); } console.log('Category order saved.'); } catch (error) { console.error('Error saving category order:', error); alert(`Error saving order: ${error.message}`); }
                    }
                });
            } else { console.error("SortableJS library not found."); }
        } catch (error) { console.error("Error rendering home page:", error); mainContent.innerHTML = '<p class="error-message">Could not load categories.</p>'; }
    }
    async function renderCategoryView(categoryName) { currentImageViewerItems = []; currentImageViewerIndex = -1; if (!mainContent || !categoryName) return; mainContent.innerHTML = '<div class="loading-indicator">Loading Items...</div>'; if (categorySortableInstance) { categorySortableInstance.destroy(); categorySortableInstance = null; } try { const response = await fetch(`/api/items?category=${encodeURIComponent(categoryName)}`); if (!response.ok) throw new Error(`Failed fetch items`); const data = await response.json(); const items = data.items || []; mainContent.innerHTML = ''; const heading = document.createElement('h2'); heading.textContent = `Category: ${categoryName}`; heading.style.marginBottom = '20px'; mainContent.appendChild(heading); const videoGrid = document.createElement('div'); videoGrid.className = 'video-grid'; if (items.length === 0) { videoGrid.textContent = 'No items found.'; } else { if (categoryName.toLowerCase() === 'image') { currentImageViewerItems = items; } items.forEach((item, index) => { const itemElement = createItemElement(item, index); videoGrid.appendChild(itemElement); }); } mainContent.appendChild(videoGrid); } catch (error) { console.error(`Error rendering category view:`, error); mainContent.innerHTML = `<p class="error-message">Could not load items.</p>`; } }

    // --- SPA Navigation ---
    function handleCategoryClick(event) { event.preventDefault(); const category = event.currentTarget.dataset.category; if (category) { currentImageViewerItems = []; currentImageViewerIndex = -1; const newUrl = `/category/${encodeURIComponent(category)}`; history.pushState({ category: category }, '', newUrl); renderCategoryView(category); } }
    function handlePopState(event) { currentImageViewerItems = []; currentImageViewerIndex = -1; if (event.state && event.state.category) { renderCategoryView(event.state.category); } else { renderHomePage(); } }
    function navigateHome(event) { if(event) event.preventDefault(); currentImageViewerItems = []; currentImageViewerIndex = -1; history.pushState(null, '', '/'); renderHomePage(); }
    window.addEventListener('popstate', handlePopState);

    // --- Category Management ---
    async function loadCategories() { try { const response = await fetch('/api/categories'); if (!response.ok) { throw new Error(`HTTP error! status: ${response.status}`); } const data = await response.json(); const categories = data.categories || []; if (categoryListUl) { categoryListUl.innerHTML = ''; categories.forEach(category => { if (!category || typeof category.name === 'undefined') { console.error(`Invalid category data received:`, category); return; } const li = document.createElement('li'); if (category.image_filename) { const imgPreview = document.createElement('img'); imgPreview.src = `/images/categories/${category.image_filename}`; imgPreview.alt = `${category.name} preview`; imgPreview.style.width = '32px'; imgPreview.style.height = '32px'; imgPreview.style.objectFit = 'cover'; imgPreview.style.marginRight = '10px'; imgPreview.style.verticalAlign = 'middle'; imgPreview.onerror = function() { this.remove(); this.onerror=null; }; li.appendChild(imgPreview); } else { const imgPlaceholder = document.createElement('div'); imgPlaceholder.style.width = '32px'; imgPlaceholder.style.height = '32px'; imgPlaceholder.style.marginRight = '10px'; imgPlaceholder.style.display = 'inline-block'; li.appendChild(imgPlaceholder); } const nameSpan = document.createElement('span'); nameSpan.textContent = category.name; nameSpan.style.flexGrow = '1'; li.appendChild(nameSpan); const fileInput = document.createElement('input'); fileInput.type = 'file'; fileInput.accept = 'image/*'; fileInput.style.display = 'none'; fileInput.id = `category-img-input-${category.name.replace(/\s+/g, '-')}`; fileInput.dataset.categoryName = category.name; const uploadLabel = document.createElement('label'); uploadLabel.htmlFor = fileInput.id; uploadLabel.textContent = category.image_filename ? 'Change Image' : 'Upload Image'; uploadLabel.className = 'action-button upload-cat-img-btn'; uploadLabel.style.marginLeft = '10px'; uploadLabel.style.fontSize = '0.8em'; uploadLabel.style.padding = '2px 6px'; li.appendChild(fileInput); li.appendChild(uploadLabel); if (!defaultCategories.includes(category.name)) { const deleteBtn = document.createElement('button'); deleteBtn.textContent = 'Delete'; deleteBtn.className = 'delete-category-btn'; deleteBtn.dataset.category = category.name; li.appendChild(deleteBtn); } categoryListUl.appendChild(li); }); } else { console.error("categoryListUl element not found!"); } const currentUploadVal = uploadCategorySelect ? uploadCategorySelect.value : null; const currentEditVal = editCategorySelect ? editCategorySelect.value : null; if (uploadCategorySelect) { uploadCategorySelect.innerHTML = '<option value="" disabled selected>-- Select Category --</option>'; categories.forEach(cat => { const option = document.createElement('option'); option.value = cat.name; option.textContent = cat.name; uploadCategorySelect.appendChild(option); }); if(categories.some(c => c.name === currentUploadVal)) uploadCategorySelect.value = currentUploadVal; } else { console.error("uploadCategorySelect element not found!"); } if (editCategorySelect) { editCategorySelect.innerHTML = '<option value="" disabled>-- Select Category --</option>'; categories.forEach(cat => { const option = document.createElement('option'); option.value = cat.name; option.textContent = cat.name; editCategorySelect.appendChild(option); }); if (categories.some(c => c.name === currentEditVal)) editCategorySelect.value = currentEditVal; else if (currentEditVal) editCategorySelect.value = ''; } else { console.error("editCategorySelect element not found!"); } } catch (error) { console.error("Error inside loadCategories function:", error); } }
    async function addCategoryApiCall(formData) { if (!formData.has('name') || !formData.get('name').trim()) { throw new Error('Category name cannot be empty.'); } const response = await fetch('/api/categories', { method: 'POST', body: formData }); const result = await response.json(); if (!response.ok && response.status !== 201) { throw new Error(result.error || `HTTP error! status: ${response.status}`); } return result; }
    async function handleAddCategoryFromSettings() { const nameToAdd = newCategoryInput ? newCategoryInput.value.trim() : ''; const statusElement = settingsCategoryStatus; const inputElement = newCategoryInput; const buttonElement = addCategoryButton; if (!nameToAdd) { alert('Please enter a category name.'); if (inputElement) inputElement.focus(); return; } if (statusElement) statusElement.textContent = 'Adding...'; if (buttonElement) buttonElement.disabled = true; try { const formData = new FormData(); formData.append('name', nameToAdd); const result = await addCategoryApiCall(formData); if (inputElement) inputElement.value = ''; if (statusElement) statusElement.textContent = result.message || `Category '${nameToAdd}' added.`; await loadCategories(); await loadAvailableThemes(); await renderHomePage(); } catch (error) { console.error("Failed add category from settings:", error); alert(`Error adding category: ${error.message}`); if (statusElement) statusElement.textContent = `Error: ${error.message}`; } finally { if (buttonElement) buttonElement.disabled = false; } }
    async function handleAddCategoryFromModalSubmit(event) { event.preventDefault(); const nameToAdd = addCategoryModalInput ? addCategoryModalInput.value.trim() : ''; const imageFile = addCategoryModalImageInput ? addCategoryModalImageInput.files[0] : null; const statusElement = addCategoryModalStatus; const buttonElement = addCategoryModalSubmitButton; if (!nameToAdd) { alert('Please enter a category name.'); if (addCategoryModalInput) addCategoryModalInput.focus(); return; } if (statusElement) statusElement.textContent = 'Adding...'; if (buttonElement) buttonElement.disabled = true; const formData = new FormData(); formData.append('name', nameToAdd); if (imageFile) formData.append('category_image', imageFile); try { const result = await addCategoryApiCall(formData); if (addCategoryModalForm) addCategoryModalForm.reset(); if (statusElement) statusElement.textContent = result.message || `Category '${nameToAdd}' added.`; await loadCategories(); await loadAvailableThemes(); await renderHomePage(); closeAddCategoryModal(); } catch (error) { console.error("Failed add category from modal:", error); alert(`Error adding category: ${error.message}`); if (statusElement) statusElement.textContent = `Error: ${error.message}`; } finally { if (buttonElement) buttonElement.disabled = false; } }
    async function deleteCategory(categoryName) { if (!categoryName) return; if (defaultCategories.includes(categoryName)) { alert('Cannot delete default categories.'); return; } if (!confirm(`Are you sure you want to delete category "${categoryName}"? Items will be moved to "Other".`)) { return; } try { const response = await fetch(`/api/categories/${encodeURIComponent(categoryName)}`, { method: 'DELETE' }); if (!response.ok) { const errorData = await response.json(); throw new Error(errorData.error || `HTTP error! status: ${response.status}`); } await loadCategories(); await loadAvailableThemes(); await renderHomePage(); const currentPath = window.location.pathname; if (currentPath === `/category/${encodeURIComponent(categoryName)}`) { navigateHome(); } } catch (error) { console.error("Failed delete category:", error); alert(`Error deleting category: ${error.message}`); } }
    async function uploadCategoryImage(categoryName, file) { if (!categoryName || !file) { console.error("Category name or file missing."); return; } const formData = new FormData(); formData.append('category_image', file); try { const response = await fetch(`/api/categories/${encodeURIComponent(categoryName)}/image`, { method: 'POST', body: formData }); if (!response.ok) { const errorData = await response.json(); throw new Error(errorData.error || `HTTP error! status: ${response.status}`); } await loadCategories(); } catch (error) { console.error(`Failed upload image:`, error); alert(`Error uploading image: ${error.message}`); } }

    // --- Modal Open/Close ---
    function openUploadModal() { if (uploadModal && uploadOverlay) { uploadModal.classList.add('visible'); uploadOverlay.classList.add('visible'); } } function closeUploadModal() { if (uploadModal && uploadOverlay) { uploadModal.classList.remove('visible'); uploadOverlay.classList.remove('visible'); } } function openEditModal(videoData) { if (editModal && editOverlay && editForm) { editTitleInput.value = videoData.title; editDescriptionInput.value = videoData.description; editFilenameSpan.textContent = videoData.filename; editCategorySelect.value = videoData.category || ""; editForm.action = `/update/${videoData.id}`; editModal.classList.add('visible'); editOverlay.classList.add('visible'); } else { console.error('Edit modal elements missing!'); } } function closeEditModal() { if (editModal && editOverlay) { editModal.classList.remove('visible'); editOverlay.classList.remove('visible'); } } function openSettingsModal(focusCategoryInput = false) { if (settingsModal && settingsOverlay) { settingsModal.classList.add('visible'); settingsOverlay.classList.add('visible'); loadCategories(); loadAvailableThemes(); loadCurrentMediaPath(); if (focusCategoryInput && newCategoryInput) { setTimeout(() => { newCategoryInput.focus(); newCategoryInput.scrollIntoView({ behavior: 'smooth', block: 'center' }); }, 100); } } } function closeSettingsModal() { if (settingsModal && settingsOverlay) { settingsModal.classList.remove('visible'); settingsOverlay.classList.remove('visible'); } } function openImageViewer(src, index) { if (imageViewerModal && imageViewerOverlay && imageViewerImg && index >= 0 && index < currentImageViewerItems.length) { currentImageViewerIndex = index; imageViewerImg.onload = () => { imageViewerModal.classList.add('visible'); imageViewerOverlay.classList.add('visible'); updateImageViewerNavButtons(); }; imageViewerImg.onerror = () => { console.error("Failed load image:", src); alert("Could not load image."); }; imageViewerImg.src = src; } else { console.error("Image viewer elements missing or index out of bounds!"); } } function closeImageViewer() { if (imageViewerModal && imageViewerOverlay && imageViewerImg) { imageViewerModal.classList.remove('visible'); imageViewerOverlay.classList.remove('visible'); imageViewerImg.src = ''; imageViewerImg.onload = null; imageViewerImg.onerror = null; currentImageViewerItems = []; currentImageViewerIndex = -1; } } function openAddCategoryModal() { if(addCategoryModal && addCategoryModalOverlay) { if(addCategoryModalForm) addCategoryModalForm.reset(); if(addCategoryModalStatus) addCategoryModalStatus.textContent = ''; addCategoryModal.classList.add('visible'); addCategoryModalOverlay.classList.add('visible'); if(addCategoryModalInput) addCategoryModalInput.focus(); } } function closeAddCategoryModal() { if(addCategoryModal && addCategoryModalOverlay) { addCategoryModal.classList.remove('visible'); addCategoryModalOverlay.classList.remove('visible'); } }
    function updateImageViewerNavButtons() { if (!imageViewerPrevBtn || !imageViewerNextBtn) return; imageViewerPrevBtn.disabled = (currentImageViewerIndex <= 0); imageViewerNextBtn.disabled = (currentImageViewerIndex >= currentImageViewerItems.length - 1); } function showPrevImage() { if (currentImageViewerIndex > 0) { currentImageViewerIndex--; const prevItem = currentImageViewerItems[currentImageViewerIndex]; if (prevItem && prevItem.filename) { imageViewerImg.src = `/serve/${prevItem.filename}`; updateImageViewerNavButtons(); } } } function showNextImage() { if (currentImageViewerIndex < currentImageViewerItems.length - 1) { currentImageViewerIndex++; const nextItem = currentImageViewerItems[currentImageViewerIndex]; if (nextItem && nextItem.filename) { imageViewerImg.src = `/serve/${nextItem.filename}`; updateImageViewerNavButtons(); } } }

    // --- Theme Handling ---
    function updateDeleteThemeButtonVisibility() { if (!themeSelect || !deleteSelectedThemeButton) return; const selectedTheme = themeSelect.value; if (selectedTheme && selectedTheme !== 'default') { deleteSelectedThemeButton.style.display = 'inline-block'; } else { deleteSelectedThemeButton.style.display = 'none'; } }
    async function loadAvailableThemes() { if (!themeSelect) { console.error("Theme select element not found"); return; }; themeSelect.innerHTML = '<option value="">Loading...</option>'; try { const [themesResponse, currentThemeResponse] = await Promise.all([ fetch('/api/themes/available'), fetch('/api/settings/theme') ]); if (!themesResponse.ok) throw new Error('Failed fetch available themes'); if (!currentThemeResponse.ok) throw new Error('Failed fetch current theme'); const themesData = await themesResponse.json(); const currentThemeData = await currentThemeResponse.json(); const availableThemes = themesData.themes || []; const currentTheme = currentThemeData.theme || 'default'; themeSelect.innerHTML = ''; if (availableThemes.length === 0) { const option = document.createElement('option'); option.textContent = 'No themes found'; option.disabled = true; themeSelect.appendChild(option); return; } availableThemes.forEach(themeName => { const option = document.createElement('option'); option.value = themeName; option.textContent = themeName.charAt(0).toUpperCase() + themeName.slice(1); themeSelect.appendChild(option); }); themeSelect.value = currentTheme; updateDeleteThemeButtonVisibility(); } catch (error) { console.error("Error loading available themes:", error); const option = document.createElement('option'); option.textContent = 'Error loading'; option.disabled = true; themeSelect.innerHTML = ''; themeSelect.appendChild(option); updateDeleteThemeButtonVisibility(); } }
    async function handleSaveThemeClick() { if (!themeSelect || !saveThemeButton) return; const selectedTheme = themeSelect.value; if (!selectedTheme) { alert("Select theme."); return; } saveThemeButton.disabled = true; saveThemeButton.textContent = 'Saving...'; if (themeStatus) themeStatus.textContent = ''; try { const response = await fetch('/api/settings/theme', { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ theme: selectedTheme }), }); if (!response.ok) { const errorData = await response.json(); throw new Error(errorData.error || 'Failed update theme'); } sessionStorage.setItem('themeApplyAttempt', selectedTheme); window.location.reload(); } catch (error) { console.error('Error saving theme preference:', error); alert(`Failed to save theme: ${error.message}`); if (themeStatus) themeStatus.textContent = `Error: ${error.message}`; saveThemeButton.disabled = false; saveThemeButton.textContent = 'Save Theme'; } }
    async function handleDeleteThemeClick() { if (!themeSelect || !deleteSelectedThemeButton) return; const selectedTheme = themeSelect.value; if (!selectedTheme || selectedTheme === 'default') { alert("Cannot delete default."); return; } if (!confirm(`DELETE theme "${selectedTheme}"?`)) { return; } if (themeStatus) themeStatus.textContent = `Deleting ${selectedTheme}...`; deleteSelectedThemeButton.disabled = true; saveThemeButton.disabled = true; try { const response = await fetch(`/api/themes/${encodeURIComponent(selectedTheme)}`, { method: 'DELETE' }); const result = await response.json(); if (!response.ok) { throw new Error(result.error || `HTTP error! status: ${response.status}`); } if (themeStatus) themeStatus.textContent = result.message || `Theme ${selectedTheme} deleted.`; await loadAvailableThemes(); const currentThemeResponse = await fetch('/api/settings/theme'); const currentThemeData = await currentThemeResponse.json(); if(selectedTheme === currentThemeData.theme || currentThemeData.theme === 'default'){ window.location.reload(); } } catch (error) { console.error('Error deleting theme:', error); if (themeStatus) themeStatus.textContent = `Error: ${error.message}`; alert(`Failed delete theme: ${error.message}`); } finally { deleteSelectedThemeButton.disabled = false; saveThemeButton.disabled = false; updateDeleteThemeButtonVisibility(); } }
    async function handleThemeUpload(event) { event.preventDefault(); if (!themeFileInput || !themeFileInput.files || themeFileInput.files.length === 0) { if (uploadThemeStatus) uploadThemeStatus.textContent = 'Please select a CSS file.'; return; } const file = themeFileInput.files[0]; if (!file.name.endsWith('.css')) { if (uploadThemeStatus) uploadThemeStatus.textContent = 'Error: Only .css files allowed.'; return; } if (uploadThemeStatus) uploadThemeStatus.textContent = 'Uploading theme...'; const formData = new FormData(); formData.append('theme_css_file', file); try { const response = await fetch('/api/themes/upload', { method: 'POST', body: formData, }); const result = await response.json(); if (!response.ok) { throw new Error(result.error || `HTTP error! status: ${response.status}`); } if (uploadThemeStatus) uploadThemeStatus.textContent = result.message || 'Theme uploaded!'; await loadAvailableThemes(); if (uploadThemeForm) uploadThemeForm.reset(); } catch (error) { console.error('Error uploading theme file:', error); if (uploadThemeStatus) uploadThemeStatus.textContent = `Error: ${error.message}`; } }
    async function saveCustomTheme() { if (!customThemeNameInput || !customThemeCssTextarea || !saveCustomThemeButton) return; const themeName = customThemeNameInput.value.trim(); const cssCode = customThemeCssTextarea.value.trim(); if (!themeName) { alert("Please enter a theme name."); return; } if (!cssCode) { alert("Please paste CSS code."); return; } saveCustomThemeButton.disabled = true; saveCustomThemeButton.textContent = 'Saving...'; if (customThemeStatus) customThemeStatus.textContent = ''; try { const response = await fetch('/api/themes/create', { method: 'POST', headers: { 'Content-Type': 'application/json', }, body: JSON.stringify({ name: themeName, css: cssCode }), }); const result = await response.json(); if (!response.ok && response.status !== 201) { throw new Error(result.error || `HTTP error! status: ${response.status}`); } if (customThemeStatus) customThemeStatus.textContent = result.message || `Theme '${result.themeName}' created!`; customThemeNameInput.value = ''; customThemeCssTextarea.value = ''; await loadAvailableThemes(); } catch(error) { console.error('Error saving custom theme:', error); if (customThemeStatus) customThemeStatus.textContent = `Error: ${error.message}`; alert(`Error saving custom theme: ${error.message}`); } finally { saveCustomThemeButton.disabled = false; saveCustomThemeButton.textContent = 'Save Custom Theme'; } }

    // --- Media Folder Path Handling ---
    async function loadCurrentMediaPath() { if (!mediaPathInput) return; try { const response = await fetch('/api/settings/mediafolder'); if (!response.ok) throw new Error('Failed fetch media path'); const data = await response.json(); mediaPathInput.value = data.path || 'videos'; if(mediaPathStatus) mediaPathStatus.textContent = ''; } catch (error) { console.error("Error loading media path:", error); if (mediaPathStatus) mediaPathStatus.textContent = 'Error loading path.'; mediaPathInput.value = 'videos'; } }
    async function saveMediaPath() { if (!mediaPathInput || !saveMediaPathButton) return; const newPath = mediaPathInput.value.trim(); if (!newPath) { alert('Media folder path cannot be empty.'); return; } saveMediaPathButton.disabled = true; saveMediaPathButton.textContent = 'Saving...'; if(mediaPathStatus) mediaPathStatus.textContent = ''; try { const response = await fetch('/api/settings/mediafolder', { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ path: newPath }) }); const result = await response.json(); if (!response.ok) { throw new Error(result.error || 'Failed save path'); } if(mediaPathStatus) mediaPathStatus.textContent = result.message || 'Path saved!'; } catch (error) { console.error("Error saving media path:", error); if(mediaPathStatus) mediaPathStatus.textContent = `Error: ${error.message}`; alert(`Error saving path: ${error.message}`); } finally { saveMediaPathButton.disabled = false; saveMediaPathButton.textContent = 'Save Path'; } }

    // --- Event Listeners ---
    if (uploadTriggerButton) uploadTriggerButton.addEventListener('click', openUploadModal); if (closeUploadModalButton) closeUploadModalButton.addEventListener('click', closeUploadModal); if (uploadOverlay) uploadOverlay.addEventListener('click', closeUploadModal);
    if (closeEditModalButton) closeEditModalButton.addEventListener('click', closeEditModal); if (editOverlay) editOverlay.addEventListener('click', closeEditModal);
    if (settingsTriggerButton) settingsTriggerButton.addEventListener('click', () => openSettingsModal(false)); if (closeSettingsModalButton) closeSettingsModalButton.addEventListener('click', closeSettingsModal); if (settingsOverlay) settingsOverlay.addEventListener('click', closeSettingsModal);
    if (homeLink) homeLink.addEventListener('click', navigateHome);
    if (addCategoryButton) addCategoryButton.addEventListener('click', handleAddCategoryFromSettings); if (newCategoryInput) newCategoryInput.addEventListener('keypress', (event) => { if (event.key === 'Enter') { event.preventDefault(); handleAddCategoryFromSettings(); } });
    document.addEventListener('keydown', (event) => { if (event.key === 'Escape') { closeUploadModal(); closeEditModal(); closeSettingsModal(); hideConfirmBar(); closeImageViewer(); closeAddCategoryModal(); } });
    if (mainContent) { mainContent.addEventListener('click', (event) => { if (event.target) { if (event.target.classList.contains('edit-trigger-btn')) { const button = event.target; const videoData = { id: button.dataset.videoId, title: button.dataset.videoTitle, description: button.dataset.videoDescription, filename: button.dataset.videoFilename, category: button.dataset.videoCategory }; loadCategories().then(() => openEditModal(videoData)); } else if (event.target.classList.contains('item-image-thumbnail')) { const fullSrc = event.target.dataset.fullsrc; const index = parseInt(event.target.dataset.index, 10); if (fullSrc && !isNaN(index)) { openImageViewer(fullSrc, index); } } } }); }
    if (categoryListUl) { categoryListUl.addEventListener('click', (event) => { if (event.target && event.target.classList.contains('delete-category-btn')) { const categoryName = event.target.dataset.category; deleteCategory(categoryName); } }); categoryListUl.addEventListener('change', (event) => { if (event.target && event.target.type === 'file' && event.target.dataset.categoryName) { const file = event.target.files[0]; const categoryName = event.target.dataset.categoryName; if (file) { uploadCategoryImage(categoryName, file); } } }); }
    if (uploadThemeForm) { uploadThemeForm.addEventListener('submit', handleThemeUpload); }
    if (saveMediaPathButton) { saveMediaPathButton.addEventListener('click', saveMediaPath); }
    if (saveCustomThemeButton) { saveCustomThemeButton.addEventListener('click', saveCustomTheme); }
    if (saveThemeButton) { saveThemeButton.addEventListener('click', handleSaveThemeClick); }
    if (themeSelect) { themeSelect.addEventListener('change', updateDeleteThemeButtonVisibility); }
    if (deleteSelectedThemeButton) { deleteSelectedThemeButton.addEventListener('click', handleDeleteThemeClick); }
    if (closeImageViewerButton) { closeImageViewerButton.addEventListener('click', closeImageViewer); }
    if (imageViewerOverlay) { imageViewerOverlay.addEventListener('click', closeImageViewer); }
    if (imageViewerPrevBtn) { imageViewerPrevBtn.addEventListener('click', (e) => { e.stopPropagation(); showPrevImage(); }); }
    if (imageViewerNextBtn) { imageViewerNextBtn.addEventListener('click', (e) => { e.stopPropagation(); showNextImage(); }); }
    if (closeAddCategoryModalButton) { closeAddCategoryModalButton.addEventListener('click', closeAddCategoryModal); }
    if (addCategoryModalOverlay) { addCategoryModalOverlay.addEventListener('click', closeAddCategoryModal); }
    if (addCategoryModalForm) { addCategoryModalForm.addEventListener('submit', handleAddCategoryFromModalSubmit); }


    // --- Initial Page Load ---
    loadCategories().then(() => { const initialPath = window.location.pathname; const categoryMatch = initialPath.match(/^\/category\/(.+)/); if (categoryMatch && categoryMatch[1]) { renderCategoryView(decodeURIComponent(categoryMatch[1])); } else { renderHomePage(); } }).catch(err => { console.error("Error during initial loadCategories().then():", err); });

}); // End DOMContentLoaded