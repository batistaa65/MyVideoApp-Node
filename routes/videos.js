const express = require('express');
const path = require('path');
const sqlite3 = require('sqlite3').verbose();
const multer = require('multer');
const fs = require('fs').promises;
const bodyParser = require('body-parser');

const router = express.Router();

const dbPath = path.join(__dirname, '..', 'database.db');
const PROJECT_ROOT = path.join(__dirname, '..');
let db;

// --- Database Connection & Setup ---
function connectDb() {
    db = new sqlite3.Database(dbPath, sqlite3.OPEN_READWRITE | sqlite3.OPEN_CREATE, (err) => {
        if (err) { console.error('Error connecting to database:', err.message); return; }
        console.log('Connected to the SQLite database.'); // Essential Log
        db.serialize(() => {
            db.exec(`ALTER TABLE videos ADD COLUMN category TEXT`, () => {});
            db.exec(`CREATE TABLE IF NOT EXISTS categories (name TEXT PRIMARY KEY NOT NULL UNIQUE, image_filename TEXT, order_index INTEGER)`, (createCatErr) => {
                if (!createCatErr) {
                    db.exec(`ALTER TABLE categories ADD COLUMN image_filename TEXT`, () => {});
                    db.exec(`ALTER TABLE categories ADD COLUMN order_index INTEGER`, () => {});
                    const defaults = ['Video', 'Movie', 'TV Show', 'Image', 'Other'];
                    const insertSql = 'INSERT OR IGNORE INTO categories (name) VALUES (?)';
                    defaults.forEach(cat => { db.run(insertSql, [cat], () => {}); });
                } else { console.error("Error creating/checking categories table:", createCatErr.message); }
            });
            db.exec(`CREATE TABLE IF NOT EXISTS settings (key TEXT PRIMARY KEY NOT NULL UNIQUE, value TEXT)`, (createSetErr) => {
                 if (!createSetErr) {
                     db.run(`INSERT OR IGNORE INTO settings (key, value) VALUES ('currentTheme', 'default')`, () => {});
                     db.run(`INSERT OR IGNORE INTO settings (key, value) VALUES ('mediaFolderPath', 'videos')`, () => {});
                 } else { console.error("Error creating/checking settings table:", createSetErr.message); }
            });
        });
    });
}
connectDb();

// --- Middleware ---
router.use(bodyParser.json()); // Use JSON body parser for ALL subsequent API routes on this router

// --- Multer Configurations ---
const itemStorage = multer.diskStorage({ destination: async (req, file, cb) => { try { cb(null, await getMediaFolderPath()); } catch (err) { cb(err); } }, filename: (req, file, cb) => { const uniqueSuffix=Date.now()+'-'+Math.round(Math.random()*1E9); cb(null,'item-'+uniqueSuffix+path.extname(file.originalname)); } });
const itemUpload = multer({ storage: itemStorage });
const categoryImageStorage = multer.diskStorage({ destination: (req, file, cb) => cb(null, path.join(PROJECT_ROOT, 'public/images/categories/')), filename: (req, file, cb) => { const uniqueSuffix=Date.now()+'-'+Math.round(Math.random()*1E9); cb(null,`category-${uniqueSuffix}${path.extname(file.originalname)}`); } });
const categoryImageUpload = multer({ storage: categoryImageStorage, fileFilter: (req, file, cb) => { if (!file.originalname.match(/\.(jpg|jpeg|png|gif|webp)$/i)) { return cb(new Error('Only image files are allowed!'), false); } cb(null, true); } });
const themeCssStorage = multer.diskStorage({ destination: (req, file, cb) => cb(null, path.join(PROJECT_ROOT, 'public/css/')), filename: (req, file, cb) => { let themeName = path.basename(file.originalname, '.css'); if (file.originalname.startsWith('theme-')) themeName = themeName.substring(6); const sanitizedName=themeName.toLowerCase().replace(/[^a-z0-9_-]/g,'-').replace(/-+/g,'-').substring(0,30); if (!sanitizedName || sanitizedName === 'style') return cb(new Error('Invalid theme name.'), null); cb(null, `theme-${sanitizedName}.css`); } });
const themeCssUpload = multer({ storage: themeCssStorage, fileFilter: (req, file, cb) => { if (path.extname(file.originalname).toLowerCase() !== '.css') return cb(new Error('Only .css allowed!'), false); cb(null, true); }, limits: {} });


// --- Helper Functions ---
const getSetting = (key, defaultValue) => new Promise((resolve, reject)=>{ if(!db) return reject(new Error("No DB")); db.get("SELECT value FROM settings WHERE key = ?",[key],(err, row)=>{ if(err){console.error(`Error fetch setting ${key}:`,err.message);resolve(defaultValue);}else{resolve(row?row.value:defaultValue);}}); });
async function getMediaFolderPath() { const storedPath = await getSetting('mediaFolderPath','videos'); const absolutePath = path.resolve(PROJECT_ROOT, storedPath); if (!absolutePath.startsWith(PROJECT_ROOT) && !path.isAbsolute(storedPath)) { console.warn(`Security check: Media folder path "${storedPath}" resolves outside project root. Reverting.`); return path.resolve(PROJECT_ROOT, 'videos'); } try { await fs.mkdir(absolutePath,{recursive:true}); return absolutePath; } catch (mkdirErr) { console.error(`Error creating media directory "${absolutePath}":`, mkdirErr); const defaultPath = path.resolve(PROJECT_ROOT, 'videos'); try { await fs.mkdir(defaultPath,{recursive:true}); } catch(e){} return defaultPath; } }
async function getAvailableThemes() { const cssDir=path.join(PROJECT_ROOT,'public/css'); const themes=['default']; try { const files=await fs.readdir(cssDir); files.forEach(file=>{ if (file.startsWith('theme-')&&file.endsWith('.css')) themes.push(file.substring(6,file.length-4)); }); } catch(err){console.error("Error reading CSS directory:",err);} return themes.sort(); }

// --- Main Application Routes ---
router.get('/', async (req, res) => { if (!db) { return res.status(500).render('index', { cssFile: '/css/style.css', error: 'DB failed.' }); } let currentTheme = await getSetting('currentTheme','default'); const availableThemes = await getAvailableThemes(); if (!availableThemes.includes(currentTheme)){ currentTheme = 'default'; } let cssFile = (currentTheme === 'default') ? '/css/style.css' : `/css/theme-${currentTheme}.css`; res.render('index', { cssFile: cssFile, error: null }); });
router.post('/upload', itemUpload.single('video_file'), (req, res) => { if (!db) return res.status(500).redirect('/?error=Database unavailable'); if (!req.file) return res.status(400).redirect('/?error=No file uploaded'); const { title='Untitled', description='', category='Other' } = req.body; const filename = req.file.filename; const sql = `INSERT INTO videos (filename, title, description, category) VALUES (?, ?, ?, ?)`; db.run(sql, [filename, title, description, category], function(err) { if (err) { console.error("DB error upload:", err.message); fs.unlink(req.file.path).catch(()=>{}); return res.status(500).redirect('/?error=DB error upload'); } res.redirect('/'); }); });
router.post('/update/:id', express.urlencoded({ extended: true }), (req, res) => { if (!db) return res.status(500).send('DB connection failed.'); const id = req.params.id; const { title, description, category } = req.body; const sql = `UPDATE videos SET title = ?, description = ?, category = ? WHERE id = ?`; db.run(sql, [title, description, category || 'Other', id], function(err) { if (err) { console.error("DB error update:", err.message); return res.status(500).send("Failed update."); } if (this.changes === 0) return res.status(404).send("Item not found."); res.redirect('/'); }); });
router.post('/delete/:id', async (req, res) => { if (!db) return res.status(500).send('DB connection failed.'); const id = req.params.id; const findSql = "SELECT filename FROM videos WHERE id = ?"; db.get(findSql, [id], async (err, row) => { if (err || !row || !row.filename) return res.status(err?500:404).send(err?'DB error': 'Not found or filename missing.'); const filename=row.filename; try { const mediaFolder = await getMediaFolderPath(); const filepath = path.join(mediaFolder, filename); if (!path.resolve(filepath).startsWith(mediaFolder)) { console.error(`Delete path outside media folder: ${filepath}`); return res.status(400).send('Invalid path.'); } await fs.unlink(filepath).catch(e=>{ if(e.code!=='ENOENT') console.error(`Unlink err: ${filepath}`, e);}); const deleteSql = "DELETE FROM videos WHERE id = ?"; db.run(deleteSql, [id], function(dbErr) { if (dbErr) { console.error("DB error delete:", dbErr.message); return res.status(500).send('Failed delete record.'); } if (this.changes === 0) return res.status(404).send("Not found in DB."); res.redirect('/'); }); } catch (pathErr) { console.error("Get media path err:", pathErr); res.status(500).send("Server error."); } }); });
router.get('/serve/:filename', async (req, res) => { const filename = req.params.filename; if (!filename || filename.includes('..') || filename.includes('/')) return res.status(400).send('Invalid filename'); try { const mediaFolder = await getMediaFolderPath(); const filepath = path.join(mediaFolder, filename); if (!path.resolve(filepath).startsWith(mediaFolder)) return res.status(403).send('Forbidden.'); await fs.access(filepath, fs.constants.R_OK); res.sendFile(filepath, (err)=>{if(err && !res.headersSent) res.status(err.status||500).send('Error serving');}); } catch (err) { res.status(404).send('File not found.'); } });

// --- API Routes ---
router.get('/api/items', (req, res) => { if (!db) return res.status(500).json({ error: 'DB connection failed.' }); const category = req.query.category; if (!category) return res.json({ items: [] }); const sql = "SELECT id, filename, title, description, upload_date, category FROM videos WHERE category = ? ORDER BY upload_date DESC"; db.all(sql, [category], (err, rows) => { if (err) { console.error(`Error fetching items for cat ${category}:`, err.message); return res.status(500).json({ error: 'Could not fetch items.' }); } res.json({ items: rows || [] }); }); });
router.get('/api/categories', (req, res) => { if (!db) return res.status(500).json({ error: 'DB connection failed.' }); const sql = "SELECT name, image_filename, order_index FROM categories ORDER BY order_index ASC NULLS LAST, name ASC"; db.all(sql, [], (err, rows) => { if (err) { console.error("Error fetching cats:", err.message); return res.status(500).json({ error: 'Could not fetch cats.' }); } res.json({ categories: rows }); }); });
router.post('/api/categories', categoryImageUpload.single('category_image'), (req, res) => { if (!db) { return res.status(500).json({ error: 'DB connection failed.' }); } const categoryName = req.body.name; const imageFile = req.file; if (!categoryName || typeof categoryName !== 'string' || categoryName.trim() === '') { if (imageFile) { fs.unlink(imageFile.path).catch(()=>{}); } return res.status(400).json({ error: 'Invalid category name.' }); } const trimmedName = categoryName.trim(); const imageFilename = imageFile ? imageFile.filename : null; const sql = `INSERT INTO categories (name, image_filename) VALUES (?, ?)`; db.run(sql, [trimmedName, imageFilename], function(err) { if (err) { if (imageFile) { fs.unlink(imageFile.path).catch(()=>{}); } if (err.message.includes('UNIQUE constraint failed')) { return res.status(200).json({ message: `Cat '${trimmedName}' already exists.` }); } else { console.error("DB error inserting cat:", err.message); return res.status(500).json({ error: 'Failed to add cat.' }); } } res.status(201).json({ category: { name: trimmedName, image_filename: imageFilename, order_index: null }, message: `Cat '${trimmedName}' created.` }); }); });
router.delete('/api/categories/:name', (req, res) => { if (!db) return res.status(500).json({ error: 'DB connection failed.' }); const categoryToDelete = req.params.name; const defaultCategories = ["Video", "Movie", "TV Show", "Image", "Other"]; if (!categoryToDelete || defaultCategories.includes(categoryToDelete)) return res.status(400).json({ error: 'Invalid or default category name.' }); db.serialize(() => { let imageToDelete = null; const findImageSql = `SELECT image_filename FROM categories WHERE name = ?`; db.get(findImageSql, [categoryToDelete], (findErr, row) => { if (row && row.image_filename) imageToDelete = row.image_filename; const updateSql = `UPDATE videos SET category = 'Other' WHERE category = ?`; db.run(updateSql, [categoryToDelete], function(updateErr) { if (updateErr) { console.error(`DB error updating items:`, updateErr.message); return res.status(500).json({ error: 'Failed update items.' }); } const deleteSql = `DELETE FROM categories WHERE name = ?`; db.run(deleteSql, [categoryToDelete], function(deleteErr) { if (deleteErr) { console.error(`DB error deleting cat:`, deleteErr.message); return res.status(500).json({ error: 'Failed delete category.' }); } if (this.changes === 0) return res.status(200).json({ message: `Cat '${categoryToDelete}' not found.` }); if (imageToDelete) { const imagePath = path.join(PROJECT_ROOT, 'public/images/categories', imageToDelete); fs.unlink(imagePath).catch(unlinkErr => { if (unlinkErr.code !== 'ENOENT') console.error(`Error deleting image file ${imagePath}:`, unlinkErr); }); } res.status(200).json({ message: `Cat '${categoryToDelete}' deleted.` }); }); }); }); }); });
router.post('/api/categories/:name/image', categoryImageUpload.single('category_image'), (req, res) => { if (!db) return res.status(500).json({ error: 'DB connection failed.' }); const categoryName = req.params.name; if (!req.file) return res.status(400).json({ error: 'No image file uploaded.' }); const newImageFilename = req.file.filename; let oldImageFilename = null; const findSql = `SELECT image_filename FROM categories WHERE name = ?`; db.get(findSql, [categoryName], (findErr, row) => { if (row && row.image_filename) oldImageFilename = row.image_filename; const updateSql = `UPDATE categories SET image_filename = ? WHERE name = ?`; db.run(updateSql, [newImageFilename, categoryName], function(updateErr) { if (updateErr) { console.error(`DB error updating image:`, updateErr.message); fs.unlink(req.file.path).catch(()=>{}); return res.status(500).json({ error: 'Failed update DB.' }); } if (this.changes === 0) { fs.unlink(req.file.path).catch(()=>{}); return res.status(404).json({ error: `Cat '${categoryName}' not found.` }); } if (oldImageFilename && oldImageFilename !== newImageFilename) { const oldImagePath = path.join(PROJECT_ROOT, 'public/images/categories', oldImageFilename); fs.unlink(oldImagePath).catch(unlinkErr => { if (unlinkErr.code !== 'ENOENT') console.error(`Error deleting old image:`, unlinkErr); }); } res.status(200).json({ image_filename: newImageFilename }); }); }); });
// Removed explicit jsonParser here
router.post('/api/categories/order', (req, res) => { if (!db) return res.status(500).json({ error: 'DB connection failed.' }); const orderedCategoryNames = req.body.order; if (!Array.isArray(orderedCategoryNames)) return res.status(400).json({ error: 'Invalid order data.' }); db.serialize(() => { db.run("BEGIN TRANSACTION", ()=>{}); const sql = `UPDATE categories SET order_index = ? WHERE name = ?`; let errorsOccurred = false; orderedCategoryNames.forEach((name, index) => { db.run(sql, [index, name], function(err) { if (err) { console.error(`Error updating order for ${name}:`, err.message); errorsOccurred = true; } }); }); const commitOrRollback = (err) => { if (err || errorsOccurred) { db.run("ROLLBACK", ()=>{}); console.error("Order update failed, rolling back."); return res.status(500).json({ error: 'Failed save order.' }); } else { db.run("COMMIT", (commitErr) => { if (commitErr) { console.error("Commit Error:", commitErr); return res.status(500).json({ error: 'Failed commit order.' }); } else { return res.status(200).json({ message: 'Order saved.' }); } }); } }; db.run("SELECT 1", commitOrRollback); }); });
router.get('/api/settings/theme', (req, res) => { if (!db) return res.status(500).json({ error: 'DB connection failed.' }); const sql = "SELECT value FROM settings WHERE key = 'currentTheme'"; db.get(sql, [], (err, row) => { if (err) { console.error("Error fetching theme:", err.message); return res.status(500).json({ error: 'Could not fetch theme.' }); } res.json({ theme: row ? row.value : 'default' }); }); });
// Removed explicit jsonParser here
router.put('/api/settings/theme', async (req, res) => { if (!db) return res.status(500).json({ error: 'DB connection failed.' }); const newTheme = req.body.theme; try { const availableThemes = await getAvailableThemes(); if (!newTheme || !availableThemes.includes(newTheme)) return res.status(400).json({ error: `Invalid theme name: ${newTheme}` }); const sql = `INSERT OR REPLACE INTO settings (key, value) VALUES ('currentTheme', ?)`; db.run(sql, [newTheme], function(err) { if (err) { console.error("DB error updating theme:", err.message); return res.status(500).json({ error: 'Failed update theme.' }); } res.status(200).json({ message: `Theme updated to ${newTheme}.` }); }); } catch (error) { console.error("Error processing theme update:", error); res.status(500).json({ error: 'Server error during theme update.' }); } });
router.get('/api/themes/available', async (req, res) => { try { const themes = await getAvailableThemes(); res.json({ themes: themes }); } catch (error) { res.status(500).json({ error: 'Failed retrieve available themes.' }); } });
router.post('/api/themes/upload', themeCssUpload.single('theme_css_file'), (req, res) => { if (!req.file) return res.status(400).json({ error: 'No theme CSS file uploaded.' }); const savedFilename = req.file.filename; const themeName = savedFilename.substring(6, savedFilename.length - 4); res.status(201).json({ message: `Theme '${themeName}' uploaded successfully as ${savedFilename}.`, themeName: themeName }); });
// Removed explicit jsonParser here
router.post('/api/themes/create', async (req, res) => { const { name, css } = req.body; if (!name || typeof name !== 'string' || name.trim().length === 0 || name.length > 30) return res.status(400).json({ error: 'Invalid theme name (max 30 chars).' }); if (!css || typeof css !== 'string' || css.trim().length === 0) return res.status(400).json({ error: 'CSS code cannot be empty.' }); const sanitizedName = name.toLowerCase().replace(/[^a-z0-9_-]/g, '-').replace(/-+/g,'-'); if (!sanitizedName || sanitizedName === 'style') return res.status(400).json({ error: 'Invalid sanitized name or cannot be "style".' }); const finalFilename = `theme-${sanitizedName}.css`; const cssDir = path.join(PROJECT_ROOT, 'public/css'); const filePath = path.join(cssDir, finalFilename); if (!path.resolve(filePath).startsWith(path.resolve(cssDir))) { console.error(`Path traversal attempt: ${finalFilename}`); return res.status(400).json({ error: 'Invalid theme name path.' }); } try { await fs.writeFile(filePath, css, 'utf8'); res.status(201).json({ message: `Theme '${sanitizedName}' created.`, themeName: sanitizedName }); } catch (err) { console.error(`Error writing custom theme ${finalFilename}:`, err); res.status(500).json({ error: 'Failed save theme file.' }); } });
router.get('/api/settings/mediafolder', async (req, res) => { try { const currentPath = await getSetting('mediaFolderPath', 'videos'); res.json({ path: currentPath }); } catch(err) { res.status(500).json({ error: 'Failed retrieve media folder path.' }); } });
// Removed explicit jsonParser here
router.put('/api/settings/mediafolder', (req, res) => { if (!db) return res.status(500).json({ error: 'DB connection failed.' }); const newPath = req.body.path; if (typeof newPath !== 'string') return res.status(400).json({ error: 'Invalid path.' }); const trimmedPath = newPath.trim(); if (!trimmedPath) return res.status(400).json({ error: 'Path cannot be empty.' }); const sql = `INSERT OR REPLACE INTO settings (key, value) VALUES ('mediaFolderPath', ?)`; db.run(sql, [trimmedPath], function(err) { if (err) { console.error("DB error updating media path:", err.message); return res.status(500).json({ error: 'Failed update media path.' }); } res.status(200).json({ message: `Media folder path updated.` }); }); });
router.delete('/api/themes/:name', async (req, res) => { if (!db) return res.status(500).json({ error: 'DB connection failed.' }); const themeName = req.params.name; const defaultThemes = ["default"]; if (!themeName || typeof themeName !== 'string' || themeName.trim() === '' || defaultThemes.includes(themeName)) return res.status(400).json({ error: 'Invalid or default theme name provided.' }); const trimmedName = themeName.trim(); const finalFilename = `theme-${trimmedName}.css`; const cssDir = path.join(PROJECT_ROOT, 'public/css'); const filePath = path.join(cssDir, finalFilename); if (!path.resolve(filePath).startsWith(path.resolve(cssDir))) { console.error(`Path traversal attempt on delete: ${finalFilename}`); return res.status(400).json({ error: 'Invalid theme name resulting in unsafe path.' }); } try { const currentTheme = await getSetting('currentTheme', 'default'); let themeResetNeeded = (currentTheme === trimmedName); await fs.unlink(filePath); console.log(`Deleted theme file: ${finalFilename}`); if (themeResetNeeded) { const sql = `INSERT OR REPLACE INTO settings (key, value) VALUES ('currentTheme', ?)`; await new Promise((resolve, reject) => { db.run(sql, ['default'], function(err) { if (err) { console.error("DB error resetting theme:", err.message); reject(err); } else { resolve(); } }); }); res.status(200).json({ message: `Theme '${trimmedName}' deleted. Active theme reset.` }); } else { res.status(200).json({ message: `Theme '${trimmedName}' deleted successfully.` }); } } catch (err) { if (err.code === 'ENOENT') { return res.status(404).json({ error: `Theme file for '${trimmedName}' not found.` }); } else { console.error(`Error deleting theme file ${finalFilename}:`, err); res.status(500).json({ error: 'Failed to delete theme file.' }); } } });

module.exports = router;
